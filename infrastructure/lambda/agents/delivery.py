
import os
import boto3
import json
from datetime import datetime
from botocore.exceptions import ClientError

dynamodb = boto3.resource("dynamodb")
ses = boto3.client("ses")
TABLE_NAME = os.environ.get("REQUEST_TABLE_NAME")
SENDER_EMAIL = os.environ.get("SENDER_EMAIL", "source@example.com") # User needs to verify this

def format_email_body(narrative, flight_data, hotel_data, weather_data):
    # Simple HTML conversion
    html = f"""
    <html>
    <body>
        <h1>Your Travel Plan</h1>
        <p>{narrative.replace(chr(10), '<br>')}</p>
        
        <hr>
        <h2>Details</h2>
        <h3>Flights</h3>
        <pre>{json.dumps(flight_data, indent=2)}</pre>
        
        <h3>Accommodation</h3>
        <pre>{json.dumps(hotel_data, indent=2)}</pre>
        
        <h3>Weather</h3>
        <p>{weather_data.get('summary', 'N/A')}</p>
        
        <footer>
            <small>Generated by Autonomous Travel Agent</small>
        </footer>
    </body>
    </html>
    """
    return html

def lambda_handler(event, context):
    print("Delivery Agent: Preparing email...")
    
    request_id = event.get("requestId")
    narrative = event.get("narrative", "No narrative generated.")
    
    # Extract data for structured email
    # Usually passed down or looked up from DB? 
    # For now, let's assume we use the narrative as primary content.
    
    status = "DELIVERED"
    
    # 1. Update DynamoDB first (Reliability)
    if request_id and TABLE_NAME:
        try:
            table = dynamodb.Table(TABLE_NAME)
            update_expr = "SET #s = :status, delivery_timestamp = :ts, narrative = :narrative"
            expr_values = {
                ":status": "COMPLETED", # "DELIVERED" logic
                ":ts": datetime.now().isoformat(),
                ":narrative": narrative
            }
            expr_names = {"#s": "status"}

            table.update_item(
                Key={"requestId": request_id},
                UpdateExpression=update_expr,
                ExpressionAttributeNames=expr_names,
                ExpressionAttributeValues=expr_values
            )
            print(f"Updated DynamoDB for {request_id}")
        except Exception as e:
            print(f"Error updating DynamoDB: {e}")
            status = "DB_UPDATE_FAILED"

    # 2. Send Email via SES
    # Only if we have a verified sender (environment variable)
    if SENDER_EMAIL and SENDER_EMAIL != "source@example.com":
        try:
            # We need a recipient. For dev, send to self (SENDER_EMAIL).
            # In real system, extracted from request or user profile.
            recipient = SENDER_EMAIL 
            
            subject = f"Your Travel Recommendation (Ref: {request_id})"
            body_html = format_email_body(narrative, {}, {}, {}) # Pass empty dicts for now to simplify
            
            ses.send_email(
                Source=SENDER_EMAIL,
                Destination={'ToAddresses': [recipient]},
                Message={
                    'Subject': {'Data': subject},
                    'Body': {'Html': {'Data': body_html}}
                }
            )
            print(f"Email sent to {recipient}")
        except ClientError as e:
            print(f"SES Error: {e}")
            status = "EMAIL_FAILED_SES_ERROR" # But workflow succeeded
            # Don't fail the Step Function just because email failed (soft fail)
    else:
        print("Skipping SES: SENDER_EMAIL not configured.")
        status = "EMAIL_SKIPPED"

    return {
        "status": status,
        "requestId": request_id
    }
